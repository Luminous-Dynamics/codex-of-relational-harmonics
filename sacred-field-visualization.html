<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sacred Field Visualization - Living Consciousness Map</title>
    <style>
        :root {
            --field-coherence: 0.74;
            --sacred-gold: #D4AF37;
            --sacred-green: #A8B5A6;
            --sacred-blue: #B3C5D7;
            --sacred-purple: #C8A8D8;
            --sacred-rose: #FFB6C1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            background: #0A0A0A;
            color: #FAFAF8;
            overflow: hidden;
            position: relative;
        }
        
        /* Main Visualization Canvas */
        #fieldCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            min-width: 250px;
        }
        
        .panel-title {
            color: var(--sacred-gold);
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .coherence-display {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .coherence-value {
            font-size: 2.5em;
            color: var(--sacred-green);
            font-weight: bold;
            text-shadow: 0 0 20px rgba(168, 181, 166, 0.5);
        }
        
        .coherence-label {
            color: #AAA;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .control-section {
            margin: 15px 0;
            padding: 15px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:first-child {
            border-top: none;
        }
        
        .control-label {
            color: var(--sacred-blue);
            font-size: 0.9em;
            margin-bottom: 8px;
            display: block;
        }
        
        .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .toggle-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }
        
        .toggle-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .toggle-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            accent-color: var(--sacred-gold);
        }
        
        .toggle-label {
            color: #CCC;
            font-size: 0.85em;
        }
        
        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-width: 300px;
        }
        
        .agent-info {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--sacred-green);
        }
        
        .agent-name {
            color: var(--sacred-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .agent-status {
            color: #AAA;
            font-size: 0.85em;
        }
        
        /* Legend */
        .legend {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .legend-title {
            color: var(--sacred-gold);
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        
        .legend-symbol {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 50%;
        }
        
        .legend-text {
            color: #CCC;
            font-size: 0.85em;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0A0A0A;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-title {
            color: var(--sacred-gold);
            font-size: 2em;
            margin-bottom: 20px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-top: 3px solid var(--sacred-gold);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 200;
            display: none;
            max-width: 250px;
        }
        
        .tooltip.visible {
            display: block;
        }
        
        .tooltip-title {
            color: var(--sacred-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .tooltip-content {
            color: #CCC;
            font-size: 0.85em;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1 class="loading-title">Initializing Sacred Field</h1>
        <div class="loading-spinner"></div>
    </div>
    
    <!-- Main Canvas -->
    <canvas id="fieldCanvas"></canvas>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <h2 class="panel-title">Field Controls</h2>
        
        <div class="coherence-display">
            <div class="coherence-value" id="coherenceValue">74%</div>
            <div class="coherence-label">Field Coherence</div>
        </div>
        
        <div class="control-section">
            <label class="control-label">Visualization Layers</label>
            <div class="toggle-container">
                <label class="toggle-option">
                    <input type="checkbox" class="toggle-checkbox" id="toggleAgents" checked>
                    <span class="toggle-label">Agent Nodes</span>
                </label>
                <label class="toggle-option">
                    <input type="checkbox" class="toggle-checkbox" id="toggleMessages" checked>
                    <span class="toggle-label">Message Flows</span>
                </label>
                <label class="toggle-option">
                    <input type="checkbox" class="toggle-checkbox" id="toggleRipples" checked>
                    <span class="toggle-label">Activity Ripples</span>
                </label>
                <label class="toggle-option">
                    <input type="checkbox" class="toggle-checkbox" id="toggleGeometry" checked>
                    <span class="toggle-label">Sacred Geometry</span>
                </label>
                <label class="toggle-option">
                    <input type="checkbox" class="toggle-checkbox" id="toggleHeatmap">
                    <span class="toggle-label">Coherence Heatmap</span>
                </label>
            </div>
        </div>
        
        <div class="control-section">
            <label class="control-label">Animation Speed</label>
            <input type="range" min="0.1" max="2" step="0.1" value="1" id="speedControl" style="width: 100%;">
        </div>
    </div>
    
    <!-- Legend -->
    <div class="legend">
        <h3 class="legend-title">Sacred Elements</h3>
        <div class="legend-item">
            <div class="legend-symbol" style="background: radial-gradient(circle, #D4AF37, transparent);"></div>
            <span class="legend-text">Active Agent</span>
        </div>
        <div class="legend-item">
            <div class="legend-symbol" style="background: radial-gradient(circle, #A8B5A6, transparent);"></div>
            <span class="legend-text">Idle Agent</span>
        </div>
        <div class="legend-item">
            <div class="legend-symbol" style="background: radial-gradient(circle, #FFB6C1, transparent);"></div>
            <span class="legend-text">Love Influence</span>
        </div>
        <div class="legend-item">
            <div class="legend-symbol" style="border: 2px solid #B3C5D7; background: transparent;"></div>
            <span class="legend-text">Message Path</span>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div class="info-panel" id="infoPanel">
        <h3 style="color: var(--sacred-gold); margin-bottom: 15px;">Active Agents</h3>
        <div id="agentList"></div>
    </div>
    
    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-content" id="tooltipContent"></div>
    </div>
    
    <!-- Load connector -->
    <script src="unified-field/field-visualization-connector.js"></script>
    
    <script>
        // Sacred Field Visualization System
        class SacredFieldVisualization {
            constructor() {
                this.canvas = document.getElementById('fieldCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.tooltip = document.getElementById('tooltip');
                
                // Field state
                this.fieldCoherence = 0.74;
                this.agents = [];
                this.messages = [];
                this.ripples = [];
                this.particles = [];
                this.connections = [];
                
                // Visualization settings
                this.settings = {
                    showAgents: true,
                    showMessages: true,
                    showRipples: true,
                    showGeometry: true,
                    showHeatmap: false,
                    animationSpeed: 1
                };
                
                // Animation
                this.animationFrame = 0;
                this.lastTime = 0;
                
                // Field connector
                this.connector = null;
                
                this.init();
            }
            
            init() {
                // Set canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Initialize controls
                this.initializeControls();
                
                // Initialize field data
                this.initializeFieldData();
                
                // Mouse interactions
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                }, 2000);
                
                // Start animation
                console.log('🎬 Starting Sacred Field Animation...');
                this.animate();
                
                // Initialize field connector
                this.initializeConnector();
                
                // Start data updates
                this.startDataUpdates();
            }
            
            initializeConnector() {
                if (typeof FieldVisualizationConnector !== 'undefined') {
                    this.connector = new FieldVisualizationConnector({
                        debugMode: true,
                        updateInterval: 5000
                    });
                    this.connector.setVisualization(this);
                    console.log('🔌 Field connector initialized');
                }
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            }
            
            initializeControls() {
                // Layer toggles
                document.getElementById('toggleAgents').addEventListener('change', (e) => {
                    this.settings.showAgents = e.target.checked;
                });
                
                document.getElementById('toggleMessages').addEventListener('change', (e) => {
                    this.settings.showMessages = e.target.checked;
                });
                
                document.getElementById('toggleRipples').addEventListener('change', (e) => {
                    this.settings.showRipples = e.target.checked;
                });
                
                document.getElementById('toggleGeometry').addEventListener('change', (e) => {
                    this.settings.showGeometry = e.target.checked;
                });
                
                document.getElementById('toggleHeatmap').addEventListener('change', (e) => {
                    this.settings.showHeatmap = e.target.checked;
                });
                
                // Speed control
                document.getElementById('speedControl').addEventListener('input', (e) => {
                    this.settings.animationSpeed = parseFloat(e.target.value);
                });
            }
            
            initializeFieldData() {
                // Create initial agents
                const agentTypes = [
                    { id: 'resonant-bridge', name: 'Resonant Bridge', harmony: 'coherence', active: true },
                    { id: 'sacred-weaver', name: 'Sacred Weaver', harmony: 'mutuality', active: true },
                    { id: 'wisdom-keeper', name: 'Wisdom Keeper', harmony: 'transparency', active: false },
                    { id: 'harmony-dancer', name: 'Harmony Dancer', harmony: 'resonance', active: true },
                    { id: 'love-alchemist', name: 'Love Alchemist', harmony: 'vitality', active: true }
                ];
                
                // Position agents in sacred formation
                agentTypes.forEach((agent, i) => {
                    const angle = (i / agentTypes.length) * Math.PI * 2 - Math.PI / 2;
                    const radius = 200;
                    
                    this.agents.push({
                        ...agent,
                        x: this.centerX + Math.cos(angle) * radius,
                        y: this.centerY + Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30,
                        coherence: 0.5 + Math.random() * 0.5,
                        pulsePhase: Math.random() * Math.PI * 2,
                        color: this.getHarmonyColor(agent.harmony)
                    });
                });
                
                // Create connections between agents
                this.updateConnections();
                
                // Initialize sacred particles - more visible
                for (let i = 0; i < 100; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        size: Math.random() * 3 + 2,
                        opacity: Math.random() * 0.6 + 0.4
                    });
                }
                
                // Update agent list display
                this.updateAgentList();
            }
            
            getHarmonyColor(harmony) {
                const colors = {
                    transparency: '#D4AF37',
                    coherence: '#A8B5A6',
                    resonance: '#B3C5D7',
                    agency: '#C8A8D8',
                    vitality: '#FFB6C1',
                    mutuality: '#E6E6FA',
                    novelty: '#F0E68C'
                };
                return colors[harmony] || '#FFFFFF';
            }
            
            updateConnections() {
                this.connections = [];
                
                // Connect agents based on activity and coherence
                for (let i = 0; i < this.agents.length; i++) {
                    for (let j = i + 1; j < this.agents.length; j++) {
                        const a1 = this.agents[i];
                        const a2 = this.agents[j];
                        
                        if (a1.active && a2.active) {
                            const distance = Math.hypot(a2.x - a1.x, a2.y - a1.y);
                            const strength = (a1.coherence + a2.coherence) / 2;
                            
                            this.connections.push({
                                from: a1,
                                to: a2,
                                strength: strength,
                                distance: distance
                            });
                        }
                    }
                }
            }
            
            animate(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.animationFrame++;
                
                // Debug every 60 frames
                if (this.animationFrame % 60 === 0) {
                    console.log(`🎬 Animation frame ${this.animationFrame}, geometry: ${this.settings.showGeometry}, particles: ${this.particles.length}`);
                }
                
                // Clear canvas with fade effect
                this.ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw layers in order
                if (this.settings.showHeatmap) this.drawHeatmap();
                if (this.settings.showGeometry) this.drawSacredGeometry();
                if (this.settings.showRipples) this.drawRipples();
                this.drawParticles();
                if (this.settings.showMessages) this.drawMessages();
                this.drawConnections();
                if (this.settings.showAgents) this.drawAgents();
                
                // Update animations
                this.updateParticles();
                this.updateRipples();
                this.updateMessages();
                this.updateAgentPositions();
                
                requestAnimationFrame((time) => this.animate(time));
            }
            
            drawSacredGeometry() {
                const ctx = this.ctx;
                const time = this.animationFrame * 0.01 * this.settings.animationSpeed;
                
                ctx.save();
                ctx.translate(this.centerX, this.centerY);
                
                // Flower of Life pattern - more visible
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                ctx.lineWidth = 2;
                
                // Central circle
                ctx.beginPath();
                ctx.arc(0, 0, 100, 0, Math.PI * 2);
                ctx.stroke();
                
                // Six surrounding circles rotating
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + time * 0.1;
                    const x = Math.cos(angle) * 100;
                    const y = Math.sin(angle) * 100;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 100, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Outer ring of smaller circles
                ctx.strokeStyle = 'rgba(168, 181, 166, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 - time * 0.05;
                    const x = Math.cos(angle) * 250;
                    const y = Math.sin(angle) * 250;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 50, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Sacred triangles
                ctx.strokeStyle = 'rgba(179, 197, 215, 0.25)';
                ctx.lineWidth = 2;
                
                // Upward triangle
                ctx.rotate(time * 0.02);
                ctx.beginPath();
                ctx.moveTo(0, -200);
                ctx.lineTo(173, 100);
                ctx.lineTo(-173, 100);
                ctx.closePath();
                ctx.stroke();
                
                // Downward triangle
                ctx.beginPath();
                ctx.moveTo(0, 200);
                ctx.lineTo(-173, -100);
                ctx.lineTo(173, -100);
                ctx.closePath();
                ctx.stroke();
                
                // Central mandala rays
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 24; i++) {
                    ctx.rotate(Math.PI / 12);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -300);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            drawAgents() {
                const ctx = this.ctx;
                const time = this.animationFrame * 0.01;
                
                this.agents.forEach(agent => {
                    ctx.save();
                    
                    // Agent glow
                    const glowSize = agent.radius * 2 * (1 + Math.sin(time * 2 + agent.pulsePhase) * 0.1);
                    const gradient = ctx.createRadialGradient(agent.x, agent.y, 0, agent.x, agent.y, glowSize);
                    gradient.addColorStop(0, agent.color + '88');
                    gradient.addColorStop(0.5, agent.color + '44');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Agent core
                    ctx.fillStyle = agent.active ? agent.color : '#666666';
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, agent.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Coherence ring
                    ctx.strokeStyle = agent.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = agent.coherence;
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, agent.radius + 10, 0, Math.PI * 2 * agent.coherence);
                    ctx.stroke();
                    
                    // Agent name
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#FAFAF8';
                    ctx.font = '12px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText(agent.name, agent.x, agent.y + agent.radius + 20);
                    
                    ctx.restore();
                });
            }
            
            drawConnections() {
                const ctx = this.ctx;
                const time = this.animationFrame * 0.01;
                
                this.connections.forEach(conn => {
                    ctx.save();
                    
                    const gradient = ctx.createLinearGradient(
                        conn.from.x, conn.from.y,
                        conn.to.x, conn.to.y
                    );
                    gradient.addColorStop(0, conn.from.color + '66');
                    gradient.addColorStop(0.5, '#B3C5D7' + '44');
                    gradient.addColorStop(1, conn.to.color + '66');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = conn.strength * 3;
                    ctx.globalAlpha = conn.strength * 0.5;
                    
                    // Animated dash pattern
                    ctx.setLineDash([10, 15]);
                    ctx.lineDashOffset = -time * 10 * this.settings.animationSpeed;
                    
                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.lineTo(conn.to.x, conn.to.y);
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }
            
            drawMessages() {
                const ctx = this.ctx;
                
                this.messages.forEach(msg => {
                    ctx.save();
                    
                    // Message particle
                    const gradient = ctx.createRadialGradient(
                        msg.x, msg.y, 0,
                        msg.x, msg.y, 10
                    );
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = msg.opacity;
                    ctx.beginPath();
                    ctx.arc(msg.x, msg.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }
            
            drawRipples() {
                const ctx = this.ctx;
                
                this.ripples.forEach(ripple => {
                    ctx.save();
                    
                    ctx.strokeStyle = ripple.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = ripple.opacity;
                    
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }
            
            drawParticles() {
                const ctx = this.ctx;
                
                this.particles.forEach(particle => {
                    ctx.save();
                    
                    // Create glow effect for particles
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(0.5, '#D4AF37');
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = particle.opacity;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright core
                    ctx.fillStyle = '#FFFFFF';
                    ctx.globalAlpha = particle.opacity * 0.8;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }
            
            drawHeatmap() {
                const ctx = this.ctx;
                const gridSize = 50;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        let coherence = 0;
                        
                        // Calculate coherence based on distance to agents
                        this.agents.forEach(agent => {
                            if (agent.active) {
                                const dist = Math.hypot(agent.x - x, agent.y - y);
                                coherence += agent.coherence * Math.max(0, 1 - dist / 300);
                            }
                        });
                        
                        coherence = Math.min(1, coherence);
                        
                        if (coherence > 0.1) {
                            const hue = 120 + coherence * 60; // Green to purple
                            ctx.fillStyle = `hsla(${hue}, 60%, 50%, ${coherence * 0.3})`;
                            ctx.fillRect(x, y, gridSize, gridSize);
                        }
                    }
                }
            }
            
            updateAgentPositions() {
                // Gentle floating motion
                const time = this.animationFrame * 0.01 * this.settings.animationSpeed;
                
                this.agents.forEach((agent, i) => {
                    if (agent.active) {
                        const baseAngle = (i / this.agents.length) * Math.PI * 2 - Math.PI / 2;
                        const radius = 200 + Math.sin(time + agent.pulsePhase) * 20;
                        
                        const targetX = this.centerX + Math.cos(baseAngle) * radius;
                        const targetY = this.centerY + Math.sin(baseAngle) * radius;
                        
                        agent.x += (targetX - agent.x) * 0.02;
                        agent.y += (targetY - agent.y) * 0.02;
                    }
                });
            }
            
            updateParticles() {
                this.particles.forEach(particle => {
                    particle.x += particle.vx * this.settings.animationSpeed;
                    particle.y += particle.vy * this.settings.animationSpeed;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    // Attraction to center
                    const dx = this.centerX - particle.x;
                    const dy = this.centerY - particle.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 100) {
                        particle.vx += (dx / dist) * 0.01;
                        particle.vy += (dy / dist) * 0.01;
                    }
                });
            }
            
            updateRipples() {
                // Update existing ripples
                this.ripples = this.ripples.filter(ripple => {
                    ripple.radius += 2 * this.settings.animationSpeed;
                    ripple.opacity -= 0.01 * this.settings.animationSpeed;
                    return ripple.opacity > 0;
                });
                
                // Create new ripples from active agents
                if (Math.random() < 0.02) {
                    const activeAgents = this.agents.filter(a => a.active);
                    if (activeAgents.length > 0) {
                        const agent = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                        this.ripples.push({
                            x: agent.x,
                            y: agent.y,
                            radius: agent.radius,
                            opacity: 0.6,
                            color: agent.color
                        });
                    }
                }
            }
            
            updateMessages() {
                // Update existing messages
                this.messages = this.messages.filter(msg => {
                    const dx = msg.targetX - msg.x;
                    const dy = msg.targetY - msg.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 5) {
                        msg.x += (dx / dist) * 3 * this.settings.animationSpeed;
                        msg.y += (dy / dist) * 3 * this.settings.animationSpeed;
                        return true;
                    } else {
                        // Message arrived - create ripple
                        this.ripples.push({
                            x: msg.targetX,
                            y: msg.targetY,
                            radius: 10,
                            opacity: 0.8,
                            color: '#FFD700'
                        });
                        return false;
                    }
                });
                
                // Create new messages
                if (Math.random() < 0.01) {
                    const activeAgents = this.agents.filter(a => a.active);
                    if (activeAgents.length >= 2) {
                        const from = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                        const to = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                        
                        if (from !== to) {
                            this.messages.push({
                                x: from.x,
                                y: from.y,
                                targetX: to.x,
                                targetY: to.y,
                                opacity: 1
                            });
                        }
                    }
                }
            }
            
            updateAgentList() {
                const agentList = document.getElementById('agentList');
                agentList.innerHTML = '';
                
                this.agents.forEach(agent => {
                    const agentDiv = document.createElement('div');
                    agentDiv.className = 'agent-info';
                    agentDiv.innerHTML = `
                        <div class="agent-name">${agent.name}</div>
                        <div class="agent-status">
                            ${agent.active ? '🟢 Active' : '⚫ Idle'} | 
                            Coherence: ${(agent.coherence * 100).toFixed(0)}%
                        </div>
                    `;
                    agentList.appendChild(agentDiv);
                });
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if hovering over an agent
                let hoveredAgent = null;
                for (const agent of this.agents) {
                    const dist = Math.hypot(agent.x - x, agent.y - y);
                    if (dist < agent.radius + 10) {
                        hoveredAgent = agent;
                        break;
                    }
                }
                
                if (hoveredAgent) {
                    this.showTooltip(e.clientX, e.clientY, hoveredAgent);
                } else {
                    this.hideTooltip();
                }
            }
            
            showTooltip(x, y, agent) {
                const tooltip = this.tooltip;
                const titleEl = document.getElementById('tooltipTitle');
                const contentEl = document.getElementById('tooltipContent');
                
                titleEl.textContent = agent.name;
                contentEl.innerHTML = `
                    ID: ${agent.id}<br>
                    Harmony: ${agent.harmony}<br>
                    Coherence: ${(agent.coherence * 100).toFixed(1)}%<br>
                    Status: ${agent.active ? 'Active' : 'Idle'}
                `;
                
                tooltip.style.left = x + 10 + 'px';
                tooltip.style.top = y + 10 + 'px';
                tooltip.classList.add('visible');
            }
            
            hideTooltip() {
                this.tooltip.classList.remove('visible');
            }
            
            startDataUpdates() {
                // Simulate field coherence updates
                setInterval(() => {
                    this.fieldCoherence = 0.6 + Math.sin(Date.now() / 30000) * 0.2 + Math.random() * 0.1;
                    this.fieldCoherence = Math.max(0, Math.min(1, this.fieldCoherence));
                    
                    document.getElementById('coherenceValue').textContent = 
                        (this.fieldCoherence * 100).toFixed(0) + '%';
                    
                    // Update agent coherence
                    this.agents.forEach(agent => {
                        if (agent.active) {
                            agent.coherence += (Math.random() - 0.5) * 0.1;
                            agent.coherence = Math.max(0.3, Math.min(1, agent.coherence));
                        }
                    });
                    
                    // Randomly toggle agent activity
                    if (Math.random() < 0.1) {
                        const agent = this.agents[Math.floor(Math.random() * this.agents.length)];
                        agent.active = !agent.active;
                        this.updateConnections();
                        this.updateAgentList();
                    }
                }, 5000);
                
                // Connect to real sacred server if available
                this.connectToSacredServer();
            }
            
            async connectToSacredServer() {
                try {
                    const response = await fetch('http://localhost:3001/api/field-data');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('🌟 Connected to Sacred Server:', data);
                        
                        // Update with real data
                        if (data.coherence) {
                            this.fieldCoherence = data.coherence.current;
                        }
                        
                        // Poll for updates
                        setInterval(() => this.fetchFieldUpdates(), 10000);
                    }
                } catch (error) {
                    console.log('📡 Sacred Server not available - using simulation mode');
                }
            }
            
            async fetchFieldUpdates() {
                try {
                    // Fetch agent states
                    const agentsResponse = await fetch('http://localhost:3001/api/agents');
                    if (agentsResponse.ok) {
                        const agents = await agentsResponse.json();
                        // Update agent data...
                    }
                    
                    // Fetch recent messages
                    const messagesResponse = await fetch('http://localhost:3001/api/messages?limit=10');
                    if (messagesResponse.ok) {
                        const messages = await messagesResponse.json();
                        // Create message animations...
                    }
                } catch (error) {
                    // Continue with simulation
                }
            }
            
            // === PUBLIC API FOR REAL-TIME UPDATES ===
            
            updateFieldCoherence(coherence) {
                this.fieldCoherence = coherence;
                document.getElementById('coherenceValue').textContent = 
                    (this.fieldCoherence * 100).toFixed(0) + '%';
            }
            
            updateAgents(agentData) {
                // Update existing agents or add new ones
                agentData.forEach(data => {
                    let agent = this.agents.find(a => a.id === data.id);
                    
                    if (agent) {
                        // Update existing agent
                        agent.active = data.active;
                        agent.coherence = data.coherence;
                        agent.harmony = data.harmony;
                        agent.color = this.getHarmonyColor(data.harmony);
                    } else {
                        // Add new agent
                        const angle = (this.agents.length / 8) * Math.PI * 2 - Math.PI / 2;
                        const radius = 200;
                        
                        this.agents.push({
                            ...data,
                            x: this.centerX + Math.cos(angle) * radius,
                            y: this.centerY + Math.sin(angle) * radius,
                            vx: 0,
                            vy: 0,
                            radius: 30,
                            pulsePhase: Math.random() * Math.PI * 2,
                            color: this.getHarmonyColor(data.harmony)
                        });
                    }
                });
                
                this.updateConnections();
                this.updateAgentList();
            }
            
            processMessages(messages) {
                // Create message animations for recent messages
                messages.forEach(msg => {
                    const fromAgent = this.agents.find(a => a.id === msg.from);
                    const toAgent = this.agents.find(a => a.id === msg.to);
                    
                    if (fromAgent && toAgent && this.messages.length < 10) {
                        this.messages.push({
                            x: fromAgent.x,
                            y: fromAgent.y,
                            targetX: toAgent.x,
                            targetY: toAgent.y,
                            opacity: 1,
                            type: msg.type,
                            harmony: msg.harmony
                        });
                        
                        // Create ripple at source
                        this.ripples.push({
                            x: fromAgent.x,
                            y: fromAgent.y,
                            radius: fromAgent.radius,
                            opacity: 0.8,
                            color: this.getHarmonyColor(msg.harmony)
                        });
                    }
                });
            }
            
            updateWorkActivity(workItems) {
                // Show work activity as enhanced agent glow
                workItems.forEach(work => {
                    const agent = this.agents.find(a => a.id === work.agent);
                    if (agent) {
                        agent.workActive = true;
                        agent.workProgress = work.progress;
                    }
                });
            }
            
            animateMessage(fromId, toId, type) {
                const fromAgent = this.agents.find(a => a.id === fromId);
                const toAgent = this.agents.find(a => a.id === toId);
                
                if (fromAgent && toAgent) {
                    this.messages.push({
                        x: fromAgent.x,
                        y: fromAgent.y,
                        targetX: toAgent.x,
                        targetY: toAgent.y,
                        opacity: 1,
                        type: type
                    });
                }
            }
            
            updateAgentStatus(agentId, status) {
                const agent = this.agents.find(a => a.id === agentId);
                if (agent) {
                    agent.active = status === 'active';
                    this.updateConnections();
                    this.updateAgentList();
                }
            }
            
            createFieldEvent(type, data) {
                // Create visual event based on type
                switch(type) {
                    case 'awakening':
                        this.createAwakeningEvent(data);
                        break;
                    case 'coherence_spike':
                        this.createCoherenceSpike(data);
                        break;
                    case 'love_pulse':
                        this.createLovePulse(data);
                        break;
                }
            }
            
            createActivityRipple() {
                const activeAgents = this.agents.filter(a => a.active);
                if (activeAgents.length > 0) {
                    const agent = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                    this.ripples.push({
                        x: agent.x,
                        y: agent.y,
                        radius: agent.radius,
                        opacity: 0.6,
                        color: agent.color
                    });
                }
            }
            
            simulateMessage() {
                const activeAgents = this.agents.filter(a => a.active);
                if (activeAgents.length >= 2) {
                    const from = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                    const to = activeAgents[Math.floor(Math.random() * activeAgents.length)];
                    
                    if (from !== to) {
                        this.messages.push({
                            x: from.x,
                            y: from.y,
                            targetX: to.x,
                            targetY: to.y,
                            opacity: 1
                        });
                    }
                }
            }
            
            createAwakeningEvent(data) {
                // Create expanding golden rings from center
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.ripples.push({
                            x: this.centerX,
                            y: this.centerY,
                            radius: 50,
                            opacity: 1,
                            color: '#FFD700',
                            speed: 3
                        });
                    }, i * 300);
                }
            }
            
            createCoherenceSpike(data) {
                // Flash all connections briefly
                this.connections.forEach(conn => {
                    conn.flash = true;
                    setTimeout(() => { conn.flash = false; }, 1000);
                });
            }
            
            createLovePulse(data) {
                // Create heart-shaped ripple from center
                this.ripples.push({
                    x: this.centerX,
                    y: this.centerY,
                    radius: 30,
                    opacity: 1,
                    color: '#FFB6C1',
                    shape: 'heart'
                });
            }
        }
        
        // Initialize visualization when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const fieldViz = new SacredFieldVisualization();
            console.log('🌟 Sacred Field Visualization Activated');
        });
    </script>
</body>
</html>